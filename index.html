<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Target Scorer - Fixed</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, sans-serif; background: #0a0a0a; color: #fff; padding: 15px; }
        .container { max-width: 600px; margin: 0 auto; }
        .header { text-align: center; padding: 20px; background: linear-gradient(135deg, #ff6b00, #ffd700); border-radius: 10px; margin-bottom: 20px; }
        .header h1 { font-size: 28px; color: #000; font-weight: 900; text-transform: uppercase; letter-spacing: 3px; }
        .header .version { font-size: 12px; color: #000; margin-top: 5px; opacity: 0.7; }
        .shooter-input { background: #1a1a1a; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
        .shooter-input label { display: block; margin-bottom: 8px; color: #888; font-size: 12px; text-transform: uppercase; }
        .shooter-input input { width: 100%; padding: 12px; background: #000; border: 2px solid #333; color: #fff; font-size: 16px; border-radius: 5px; }
        .shooter-input input:focus { outline: none; border-color: #ff6b00; }
        .button-group { display: grid; gap: 15px; margin-bottom: 20px; }
        .btn { padding: 18px; font-size: 18px; font-weight: 700; text-transform: uppercase; border: none; border-radius: 8px; cursor: pointer; transition: all 0.2s; letter-spacing: 1px; }
        .btn-primary { background: linear-gradient(135deg, #ff6b00, #ff8800); color: #000; }
        .btn-primary:active { transform: scale(0.98); background: #ff6b00; }
        .btn-secondary { background: #1a1a1a; color: #fff; border: 2px solid #333; }
        .btn-secondary:active { background: #333; }
        .btn-danger { background: #ff3344; color: #fff; }
        #cameraInput { display: none; }
        #imagePreview { width: 100%; border-radius: 8px; margin: 20px 0; display: none; border: 2px solid #333; }
        .status { background: #1a1a1a; padding: 15px; border-radius: 8px; text-align: center; margin: 20px 0; border: 2px solid #333; }
        .status.processing { border-color: #ff6b00; }
        .spinner { border: 3px solid #333; border-top: 3px solid #ff6b00; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 10px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .results { display: none; }
        .score-box { background: linear-gradient(135deg, #1a1a1a, #0a0a0a); border: 3px solid #ff6b00; padding: 30px; border-radius: 10px; text-align: center; margin-bottom: 20px; }
        .score-number { font-size: 72px; font-weight: 900; color: #ffd700; margin: 10px 0; }
        .score-label { color: #888; font-size: 14px; text-transform: uppercase; letter-spacing: 2px; }
        .stats { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
        .stat-item { background: #1a1a1a; padding: 15px; border-radius: 8px; text-align: center; }
        .stat-value { font-size: 28px; font-weight: 700; color: #00ff88; }
        .stat-label { color: #888; font-size: 11px; margin-top: 5px; }
        .target-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px; margin-bottom: 20px; }
        .target-cell { background: #1a1a1a; border: 2px solid #333; padding: 10px 5px; text-align: center; border-radius: 5px; }
        .target-num { font-size: 10px; color: #666; margin-bottom: 3px; }
        .target-score { font-size: 24px; font-weight: 900; color: #ff6b00; }
        .target-x { color: #ffd700; font-size: 14px; margin-top: 2px; }
        .target-empty { opacity: 0.3; }
        #resultCanvas { width: 100%; border-radius: 8px; border: 2px solid #333; margin-bottom: 20px; background: #fff; }
        .history-section { display: none; margin-top: 30px; }
        .history-item { background: #1a1a1a; padding: 15px; border-radius: 8px; margin-bottom: 10px; border: 2px solid #333; }
        .history-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .history-id { font-weight: 700; color: #ff6b00; }
        .history-score { font-size: 32px; font-weight: 900; color: #00ff88; }
        .history-date { color: #666; font-size: 11px; }
        .history-actions { display: flex; gap: 10px; margin-top: 10px; }
        .btn-small { padding: 8px 15px; font-size: 12px; }
        .error { background: #ff3344; color: #fff; padding: 12px; border-radius: 8px; margin: 15px 0; display: none; text-align: center; font-weight: 600; }
        .section-title { color: #ff6b00; font-size: 16px; font-weight: 700; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #333; }
        .toggle-btn { background: #1a1a1a; color: #ff6b00; border: 2px solid #333; padding: 12px; font-size: 14px; font-weight: 700; text-transform: uppercase; border-radius: 8px; cursor: pointer; width: 100%; margin-bottom: 20px; }
        .toggle-btn:active { background: #333; }
        .empty-state { text-align: center; padding: 40px 20px; color: #666; }
        .info-box { background: #1a1a1a; border: 2px solid #333; padding: 12px; border-radius: 8px; margin-bottom: 20px; font-size: 12px; color: #888; }
        .info-box strong { color: #ff6b00; }
        .debug-info { background: #000; border: 1px solid #333; padding: 8px; border-radius: 4px; margin-top: 10px; font-size: 10px; color: #666; font-family: monospace; }
        @media (max-width: 500px) { .score-number { font-size: 56px; } .target-score { font-size: 18px; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ TARGET SCORER</h1>
            <div class="version">v2.0 - Fixed Scoring</div>
        </div>

        <div class="info-box">
            <strong>‚úì Fixed:</strong> Accurate mm-based scoring | Proper X-ring detection | Better hole detection
            <div class="debug-info" id="debugInfo">System ready...</div>
        </div>

        <div id="mainSection">
            <div class="shooter-input">
                <label>Shooter ID (Optional)</label>
                <input type="text" id="shooterID" placeholder="e.g., ALPHA01" maxlength="20">
            </div>

            <div class="button-group">
                <input type="file" id="cameraInput" accept="image/*" capture="environment" style="display: none;">
                <button class="btn btn-primary" onclick="openCamera()" id="cameraBtn">üì∏ TAKE PHOTO</button>
                <button class="btn btn-secondary" onclick="selectImage()" id="fileBtn">üìÅ SELECT IMAGE</button>
            </div>

            <div class="error" id="errorMessage"></div>
            <div class="status" id="statusBox" style="display: none;">
                <div class="spinner"></div>
                <p>Processing image...</p>
            </div>

            <img id="imagePreview" alt="Target Preview">

            <div class="results" id="results">
                <div class="score-box">
                    <div class="score-label">TOTAL SCORE</div>
                    <div class="score-number" id="totalScore">0</div>
                </div>

                <div class="stats">
                    <div class="stat-item"><div class="stat-value" id="shotsFired">0/25</div><div class="stat-label">SHOTS</div></div>
                    <div class="stat-item"><div class="stat-value" id="xRingHits">0</div><div class="stat-label">X-RINGS</div></div>
                    <div class="stat-item"><div class="stat-value" id="avgScore">0.0</div><div class="stat-label">AVERAGE</div></div>
                    <div class="stat-item"><div class="stat-value" id="targetsHit">0/25</div><div class="stat-label">TARGETS HIT</div></div>
                </div>

                <div class="section-title">Individual Scores</div>
                <div class="target-grid" id="targetGrid"></div>

                <canvas id="resultCanvas"></canvas>

                <div class="button-group">
                    <button class="btn btn-primary" onclick="saveResults()">üíæ SAVE RESULTS</button>
                    <button class="btn btn-secondary" onclick="resetApp()">üîÑ NEW TARGET</button>
                </div>
            </div>
        </div>

        <button class="toggle-btn" onclick="toggleHistory()">üìä VIEW SAVED RESULTS (<span id="historyCount">0</span>)</button>

        <div class="history-section" id="historySection">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div class="section-title" style="margin: 0; border: none; padding: 0;">SAVED RESULTS</div>
                <button class="btn btn-danger btn-small" onclick="clearAllHistory()">üóëÔ∏è CLEAR ALL</button>
            </div>
            <div id="historyList"></div>
        </div>
    </div>

    <script>
        console.log('Target Scorer v2.0 - Fixed');

        let currentImage = null;
        let processedResults = null;

        // Scoring configuration (in mm - matching Python script)
        const SCORING_ZONES = [
            { radius: 0.5, score: 10, name: '0.5mm(X)', isX: true },   // X-ring
            { radius: 6, score: 10, name: '6mm', isX: false },
            { radius: 9, score: 9, name: '9mm', isX: false },
            { radius: 12, score: 8, name: '12mm', isX: false },
            { radius: 15, score: 7, name: '15mm', isX: false },
            { radius: 18, score: 6, name: '18mm', isX: false },
            { radius: 21, score: 5, name: '21mm', isX: false },
            { radius: 24, score: 4, name: '24mm', isX: false }
        ];

        const BULLET_RADIUS_MM = 2.5;  // .22 bullet hole radius
        const TARGET_DIAMETER_MM = 48.0;  // 24mm radius * 2
        const TARGET_SIZE_RATIO = 0.82;  // Target occupies 82% of cell width

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM ready, setting up camera input...');
            debugLog('‚úì App loaded');
            
            const fileInput = document.getElementById('cameraInput');
            if (fileInput) {
                fileInput.addEventListener('change', handleFileSelect);
                console.log('Camera input listener attached');
                debugLog('‚úì Camera ready');
            } else {
                console.error('Camera input not found!');
                debugLog('‚úó Camera input ERROR');
            }
            
            // Initialize history count
            updateHistoryCount();
        });

        function debugLog(message) {
            const debugDiv = document.getElementById('debugInfo');
            if (debugDiv) {
                const timestamp = new Date().toLocaleTimeString();
                debugDiv.textContent = `[${timestamp}] ${message}`;
            }
            console.log(message);
        }

        function openCamera() {
            debugLog('üì∏ Opening camera...');
            const input = document.getElementById('cameraInput');
            if (!input) {
                console.error('Input element not found!');
                showError('Camera input not found');
                debugLog('‚úó Input not found');
                return;
            }
            
            // Reset input
            input.value = '';
            // Set capture mode for camera
            input.setAttribute('capture', 'environment');
            input.setAttribute('accept', 'image/*');
            
            // Trigger file picker
            try {
                input.click();
                debugLog('‚úì Camera click triggered');
            } catch (e) {
                debugLog('‚úó Click failed: ' + e.message);
                showError('Could not open camera: ' + e.message);
            }
        }

        function selectImage() {
            debugLog('üìÅ Opening file picker...');
            const input = document.getElementById('cameraInput');
            if (!input) {
                console.error('Input element not found!');
                showError('File input not found');
                debugLog('‚úó Input not found');
                return;
            }
            
            // Reset input
            input.value = '';
            // Remove capture mode for file selection
            input.removeAttribute('capture');
            input.setAttribute('accept', 'image/*');
            
            // Trigger file picker
            try {
                input.click();
                debugLog('‚úì File picker click triggered');
            } catch (e) {
                debugLog('‚úó Click failed: ' + e.message);
                showError('Could not open file picker: ' + e.message);
            }
        }

        function handleFileSelect(e) {
            debugLog('üì∑ File selected');
            const file = e.target.files[0];
            
            if (!file) {
                debugLog('‚úó No file selected');
                return;
            }

            debugLog(`‚úì ${file.name} (${Math.round(file.size/1024)}KB)`);
            
            // Validate file type
            if (!file.type.startsWith('image/')) {
                showError('Please select an image file');
                debugLog('‚úó Invalid file type: ' + file.type);
                return;
            }

            showError('');
            document.getElementById('results').style.display = 'none';
            
            // Show loading immediately
            const statusBox = document.getElementById('statusBox');
            statusBox.style.display = 'block';
            debugLog('‚è≥ Loading image...');
            
            const reader = new FileReader();
            reader.onload = function(event) {
                debugLog('‚úì Image loaded, processing...');
                const img = document.getElementById('imagePreview');
                img.src = event.target.result;
                img.style.display = 'block';
                
                // Process image immediately
                setTimeout(() => {
                    processImage(event.target.result);
                }, 100);
            };
            reader.onerror = () => {
                console.error('FileReader error');
                document.getElementById('statusBox').style.display = 'none';
                showError('Failed to load image');
                debugLog('‚úó Failed to load image');
            };
            reader.readAsDataURL(file);
        }

        function showError(message) {
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.style.display = message ? 'block' : 'none';
            errorDiv.textContent = message;
            if (message) console.error('Error:', message);
        }

        function processImage(imageSrc) {
            debugLog('üîç Analyzing image...');
            const statusBox = document.getElementById('statusBox');
            statusBox.style.display = 'block';
            
            const img = new Image();
            img.onload = function() {
                try {
                    currentImage = img;
                    debugLog(`‚úì Image: ${img.width}x${img.height}px`);
                    const results = detectAndScore(img);
                    processedResults = results;
                    displayResults(results);
                    statusBox.style.display = 'none';
                    document.getElementById('results').style.display = 'block';
                    debugLog(`‚úì Score: ${results.totalScore} (${results.xRingCount}X)`);
                    console.log('Done!', results);
                } catch (error) {
                    console.error('Error:', error);
                    statusBox.style.display = 'none';
                    showError('Error: ' + error.message);
                    debugLog('‚úó Processing error: ' + error.message);
                }
            };
            img.onerror = () => { 
                statusBox.style.display = 'none'; 
                showError('Failed to load image');
                debugLog('‚úó Image load failed');
            };
            img.src = imageSrc;
        }

        function detectAndScore(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Define grid region (5x5 grid of targets)
            const gridRegion = { 
                x: canvas.width * 0.05, 
                y: canvas.height * 0.05, 
                width: canvas.width * 0.9, 
                height: canvas.height * 0.9 
            };
            const cellWidth = gridRegion.width / 5;
            const cellHeight = gridRegion.height / 5;
            
            // Create 25 target regions
            const targets = [];
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 5; col++) {
                    const targetNum = row * 5 + col + 1;
                    const x = gridRegion.x + col * cellWidth;
                    const y = gridRegion.y + row * cellHeight;
                    targets.push({
                        number: targetNum,
                        x, y, width: cellWidth, height: cellHeight,
                        centerX: x + cellWidth / 2,
                        centerY: y + cellHeight / 2,
                        holes: [],
                        score: 0,
                        xRing: false,
                        zoneName: 'NO SHOT'
                    });
                }
            }
            
            // Detect holes in each target
            detectHolesInTargets(data, canvas.width, canvas.height, targets);
            
            // Score each target using CORRECT mm-based scoring
            scoreTargets(targets, cellWidth);
            
            // Calculate totals
            let totalScore = 0, xRingCount = 0, shotsFired = 0, targetsHit = 0;
            targets.forEach(t => {
                totalScore += t.score;
                if (t.xRing) xRingCount++;
                if (t.holes.length > 0) { 
                    shotsFired += t.holes.length;
                    targetsHit++;
                }
            });
            
            return {
                targets,
                totalScore,
                xRingCount,
                shotsFired,
                targetsHit,
                avgScore: shotsFired > 0 ? (totalScore / shotsFired).toFixed(1) : '0.0'
            };
        }

        function detectHolesInTargets(data, width, height, targets) {
            const visited = new Array(width * height).fill(false);
            
            targets.forEach(target => {
                const startX = Math.floor(target.x);
                const startY = Math.floor(target.y);
                const endX = Math.floor(target.x + target.width);
                const endY = Math.floor(target.y + target.height);
                
                // Scan target area for dark pixels (bullet holes)
                for (let y = startY; y < endY; y += 2) {
                    for (let x = startX; x < endX; x += 2) {
                        if (x < 0 || x >= width || y < 0 || y >= height) continue;
                        const idx = y * width + x;
                        if (visited[idx]) continue;
                        
                        const pixelIdx = idx * 4;
                        const brightness = (data[pixelIdx] + data[pixelIdx + 1] + data[pixelIdx + 2]) / 3;
                        
                        // CRITICAL: Very dark pixels only (35 threshold matches Python)
                        // Printed circles are gray (~120-180), bullet holes are black (~10-50)
                        if (brightness < 35) {
                            const hole = floodFill(data, width, height, x, y, visited, 35);
                            
                            // Filter by size and properties
                            if (isValidBulletHole(hole, data, width, target)) {
                                target.holes.push(hole);
                            }
                        }
                    }
                }
            });
        }

        function floodFill(data, width, height, startX, startY, visited, threshold) {
            const pixels = [];
            const queue = [{x: startX, y: startY}];
            let sumX = 0, sumY = 0;
            let minX = startX, maxX = startX, minY = startY, maxY = startY;
            
            while (queue.length > 0 && pixels.length < 1000) {
                const {x, y} = queue.shift();
                if (x < 0 || x >= width || y < 0 || y >= height) continue;
                const idx = y * width + x;
                if (visited[idx]) continue;
                
                const pixelIdx = idx * 4;
                const brightness = (data[pixelIdx] + data[pixelIdx + 1] + data[pixelIdx + 2]) / 3;
                if (brightness >= threshold) continue;
                
                visited[idx] = true;
                pixels.push({x, y});
                sumX += x;
                sumY += y;
                
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
                
                queue.push({x: x + 1, y: y});
                queue.push({x: x - 1, y: y});
                queue.push({x: x, y: y + 1});
                queue.push({x: x, y: y - 1});
            }
            
            const w = maxX - minX + 1;
            const h = maxY - minY + 1;
            const area = pixels.length;
            const boundingArea = w * h;
            
            return {
                pixels,
                centerX: sumX / pixels.length,
                centerY: sumY / pixels.length,
                width: w,
                height: h,
                area,
                solidity: boundingArea > 0 ? area / boundingArea : 0
            };
        }

        function isValidBulletHole(hole, data, imageWidth, target) {
            // Size filter (8-600 pixels matches Python)
            if (hole.area < 8 || hole.area > 600) return false;
            
            // Aspect ratio check - should be roughly circular
            if (hole.height === 0) return false;
            const aspect = hole.width / hole.height;
            if (aspect < 0.25 || aspect > 4.0) return false;
            
            // Distance from target center check
            const dx = hole.centerX - target.centerX;
            const dy = hole.centerY - target.centerY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // Must be within scoring zone but not in the very center (printed dot)
            if (dist < 2 || dist > 125) return false;
            
            // Solidity check - bullet holes are FILLED (high solidity >= 0.65)
            // Printed circles are HOLLOW (low solidity)
            if (hole.solidity < 0.65) return false;
            
            // Darkness check - must be genuinely dark
            let sumBrightness = 0;
            let count = 0;
            for (const {x, y} of hole.pixels) {
                if (x < 0 || x >= imageWidth || y < 0) continue;
                const idx = (y * imageWidth + x) * 4;
                sumBrightness += (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                count++;
            }
            const avgBrightness = count > 0 ? sumBrightness / count : 255;
            if (avgBrightness > 70) return false;
            
            return true;
        }

        function scoreTargets(targets, cellWidth) {
            targets.forEach(target => {
                if (target.holes.length === 0) {
                    target.score = 0;
                    target.xRing = false;
                    target.zoneName = 'NO SHOT';
                    return;
                }
                
                // RULE: If multiple holes, use the furthest from center (worst shot)
                const furthestHole = target.holes.reduce((max, hole) => {
                    const dx = hole.centerX - target.centerX;
                    const dy = hole.centerY - target.centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    return dist > max.dist ? {hole, dist} : max;
                }, {hole: target.holes[0], dist: 0});
                
                const hole = furthestHole.hole;
                const distancePixels = furthestHole.dist;
                
                // Calculate CORRECT score using mm-based measurements
                const result = calculateScore(distancePixels, cellWidth);
                
                target.score = result.score;
                target.xRing = result.isX;
                target.zoneName = result.zoneName;
                target.scoredHole = hole;  // Store which hole was scored
            });
        }

        function calculateScore(distancePixels, targetWidthPixels) {
            /**
             * CORRECT SCORING ALGORITHM (matches Python script)
             * 
             * Key points:
             * 1. Target diameter: 48mm (24mm radius * 2)
             * 2. Target occupies 82% of cell width
             * 3. Bullet hole radius: 2.5mm
             * 4. For X-ring: check if EDGE of bullet hole is within 0.5mm of center
             *    This means center can be up to 3mm away (0.5 + 2.5)
             */
            
            // Calibration: Convert pixels to mm
            const targetDiameterPx = targetWidthPixels * TARGET_SIZE_RATIO;
            const pixelsPerMm = targetDiameterPx / TARGET_DIAMETER_MM;
            const distanceMm = distancePixels / pixelsPerMm;
            
            // For X-ring: calculate edge distance
            const edgeDistanceMm = distanceMm - BULLET_RADIUS_MM;
            
            // Check X-ring first (special case)
            if (edgeDistanceMm <= 0.5) {
                return { score: 10, zoneName: '0.5mm(X)', isX: true };
            }
            
            // Check other zones (using center distance)
            for (const zone of SCORING_ZONES) {
                if (zone.isX) continue;  // Already checked X-ring
                if (distanceMm <= zone.radius) {
                    return { score: zone.score, zoneName: zone.name, isX: false };
                }
            }
            
            // Outside all scoring zones
            return { score: 0, zoneName: 'MISS', isX: false };
        }

        function displayResults(results) {
            document.getElementById('totalScore').textContent = results.totalScore;
            document.getElementById('shotsFired').textContent = results.shotsFired + '/25';
            document.getElementById('xRingHits').textContent = results.xRingCount;
            document.getElementById('avgScore').textContent = results.avgScore;
            document.getElementById('targetsHit').textContent = results.targetsHit + '/25';
            
            // Display target grid
            const grid = document.getElementById('targetGrid');
            grid.innerHTML = '';
            results.targets.forEach(target => {
                const cell = document.createElement('div');
                cell.className = 'target-cell' + (target.holes.length === 0 ? ' target-empty' : '');
                cell.innerHTML = `
                    <div class="target-num">T${target.number}</div>
                    <div class="target-score">${target.score}</div>
                    ${target.xRing ? '<div class="target-x">X</div>' : ''}
                `;
                grid.appendChild(cell);
            });
            
            // Draw annotated image
            const canvas = document.getElementById('resultCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = currentImage.width;
            canvas.height = currentImage.height;
            ctx.drawImage(currentImage, 0, 0);
            
            results.targets.forEach(target => {
                // Draw target boundary
                ctx.strokeStyle = 'rgba(255, 107, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(target.x, target.y, target.width, target.height);
                
                // Draw scored hole
                if (target.scoredHole) {
                    const hole = target.scoredHole;
                    ctx.beginPath();
                    ctx.arc(hole.centerX, hole.centerY, 12, 0, 2 * Math.PI);
                    ctx.strokeStyle = target.xRing ? '#ffd700' : '#00ff88';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Draw crosshair
                    ctx.beginPath();
                    ctx.moveTo(hole.centerX - 8, hole.centerY);
                    ctx.lineTo(hole.centerX + 8, hole.centerY);
                    ctx.moveTo(hole.centerX, hole.centerY - 8);
                    ctx.lineTo(hole.centerX, hole.centerY + 8);
                    ctx.stroke();
                    
                    // Draw score text
                    ctx.fillStyle = target.xRing ? '#ffd700' : '#00ff88';
                    ctx.font = 'bold 20px Arial';
                    ctx.fillText(target.score + (target.xRing ? 'X' : ''), 
                                hole.centerX + 15, hole.centerY - 10);
                }
                
                // Draw target number
                ctx.fillStyle = '#ff6b00';
                ctx.font = 'bold 16px Arial';
                ctx.fillText('#' + target.number, target.x + 5, target.y + 20);
            });
        }

        function saveResults() {
            if (!processedResults) { showError('No results to save'); return; }
            const shooterID = document.getElementById('shooterID').value.trim() || 'UNKNOWN';
            const record = {
                id: Date.now(),
                shooterID: shooterID,
                date: new Date().toISOString(),
                results: processedResults,
                imageData: document.getElementById('imagePreview').src
            };
            let records = JSON.parse(localStorage.getItem('targetScores') || '[]');
            records.push(record);
            localStorage.setItem('targetScores', JSON.stringify(records));
            updateHistoryCount();
            alert('‚úì Results saved!');
        }

        function resetApp() {
            document.getElementById('imagePreview').style.display = 'none';
            document.getElementById('results').style.display = 'none';
            document.getElementById('cameraInput').value = '';
            processedResults = null;
            showError('');
        }

        function toggleHistory() {
            const section = document.getElementById('historySection');
            section.style.display = section.style.display === 'none' || !section.style.display ? 'block' : 'none';
            if (section.style.display === 'block') loadHistory();
        }

        function loadHistory() {
            const records = JSON.parse(localStorage.getItem('targetScores') || '[]');
            const historyList = document.getElementById('historyList');
            
            if (records.length === 0) {
                historyList.innerHTML = '<div class="empty-state">No saved results yet</div>';
                return;
            }
            
            records.sort((a, b) => new Date(b.date) - new Date(a.date));
            historyList.innerHTML = records.map(r => {
                const date = new Date(r.date);
                const dateStr = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                return `<div class="history-item">
                    <div class="history-header">
                        <div>
                            <div class="history-id">${r.shooterID}</div>
                            <div class="history-date">${dateStr}</div>
                        </div>
                        <div class="history-score">${r.results.totalScore}</div>
                    </div>
                    <div style="font-size: 12px; color: #888;">
                        Shots: ${r.results.shotsFired}/25 | X: ${r.results.xRingCount} | Avg: ${r.results.avgScore}
                    </div>
                    <div class="history-actions">
                        <button class="btn btn-secondary btn-small" onclick="viewRecord(${r.id})">üëÅÔ∏è VIEW</button>
                        <button class="btn btn-danger btn-small" onclick="deleteRecord(${r.id})">üóëÔ∏è DELETE</button>
                    </div>
                </div>`;
            }).join('');
        }

        function viewRecord(id) {
            const records = JSON.parse(localStorage.getItem('targetScores') || '[]');
            const record = records.find(r => r.id === id);
            if (!record) return;
            
            document.getElementById('shooterID').value = record.shooterID;
            document.getElementById('imagePreview').src = record.imageData;
            document.getElementById('imagePreview').style.display = 'block';
            processedResults = record.results;
            currentImage = new Image();
            currentImage.src = record.imageData;
            displayResults(record.results);
            document.getElementById('results').style.display = 'block';
            toggleHistory();
            window.scrollTo(0, 0);
        }

        function deleteRecord(id) {
            if (!confirm('Delete this result?')) return;
            let records = JSON.parse(localStorage.getItem('targetScores') || '[]');
            records = records.filter(r => r.id !== id);
            localStorage.setItem('targetScores', JSON.stringify(records));
            loadHistory();
            updateHistoryCount();
        }

        function clearAllHistory() {
            if (!confirm('Delete ALL results?')) return;
            localStorage.removeItem('targetScores');
            loadHistory();
            updateHistoryCount();
        }

        function updateHistoryCount() {
            const records = JSON.parse(localStorage.getItem('targetScores') || '[]');
            document.getElementById('historyCount').textContent = records.length;
        }

        console.log('Target Scorer v2.0 Ready!');
    </script>
</body>
</html>
